## NAItemBaseDataStructs.h

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataTable.h"
#include "Interaction/NAInteractableDataStructs.h"
#include "NAItemBaseDataStructs.generated.h"

UENUM(BlueprintType)
enum class EItemType : uint8
{
	IT_None					UMETA(Hidden), // 초기화 필요

	IT_Weapon				UMETA(DisplayName = "Weapon"),
	IT_Tool					UMETA(DisplayName = "Tool"),
	IT_Armor				UMETA(DisplayName = "Armor"),

	IT_Ammo					UMETA(DisplayName = "Ammo"),
	IT_Consumable			UMETA(DisplayName = "Consumable"),
	
	//IT_WeaponEnhancement	UMETA(DisplayName = "Weapon Upgrade Material"),
	//IT_ArmorEnhancement	UMETA(DisplayName = "Armor Upgrade Material"),

// Currency Item ///////////////////////////////////////////////////////////////////////////////////////////////////////

	IT_UpgradeNode			UMETA(DisplayName = "Upgrade Node"),
	IT_Credit				UMETA(DisplayName = "Credit"),
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

	IT_Material				UMETA(DisplayName = "Material"),
	IT_QuestItem			UMETA(DisplayName = "Quest Item"),
	
	IT_Misc					UMETA(DisplayName = "Miscellaneous"),

	IT_EnvObject			UMETA(DisplayName = "Environment Object"),
};

USTRUCT()
struct FItemTextData
{
	GENERATED_BODY()

	// RowName == ItemName(소문자-대문자 사이 공백 추가)
	UPROPERTY(VisibleAnywhere, Category = "Item Text Data")
	FText Name = FText::GetEmpty();

	UPROPERTY(EditAnywhere, Category = "Item Text Data")
	FText Description = FText::GetEmpty();

	UPROPERTY(EditAnywhere, Category = "Item Text Data")
	FText UsageText = FText::GetEmpty();
};

class UGeometryCollection;
class UGeometryCollectionCache;
USTRUCT()
struct ARPG_API FNAStaticMeshItemAssetData
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Static Mesh Item Asset Data")
	TObjectPtr<UStaticMesh> StaticMesh = nullptr;

	// (선택) Fracture Geometry Collection 에셋
	UPROPERTY(EditAnywhere, Category = "Static Mesh Item Asset Data|Fracture")
	UGeometryCollection* FractureCollection = nullptr;

	// (선택) Fracture Geometry Collection 애니메이션 
	UPROPERTY(EditAnywhere, Category = "Static Mesh Item Asset Data|Fracture")
	UGeometryCollectionCache* FractureCache = nullptr;
};

USTRUCT()
struct FNASkeletalMeshItemAssetData
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Skeletal Mesh Item Asset Data")
	TObjectPtr<USkeletalMesh> SkeletalMesh = nullptr;

	// @TODO: 아이템 전용 애님 클래스 만들기?
	UPROPERTY(EditAnywhere, Category = "Skeletal Mesh Item Asset Data")
	TSubclassOf<UAnimInstance/*UItemAnimInstance*/> AnimClass;
};

UENUM(BlueprintType)
enum class EItemCollisionShape : uint8
{
	ICS_None		UMETA(DisplayName = "None"),
	
	ICS_Sphere		UMETA(DisplayName = "Sphere"),
	ICS_Box			UMETA(DisplayName = "Box"),
	ICS_Capsule		UMETA(DisplayName = "Capsule"),
};

UENUM(BlueprintType)
enum class EItemMeshType : uint8
{
	IMT_None		UMETA(DisplayName = "None"),
	
	IMT_Static		UMETA(DisplayName = "Static"),
	IMT_Skeletal	UMETA(DisplayName = "Skeletal"),
};


/**
 * 무기의 경우: bIsStackable이 true면 무조건 MaxSlotStackSize == 1 && MaxInventoryHoldCount == 1
 *			 bIsStackable이 false면 무조건 MaxSlotStackSize == -1 && MaxInventoryHoldCount == -1
*/
USTRUCT()
struct FItemNumericData
{
	GENERATED_BODY()

	/**
	 * 인벤토리의 슬롯 1칸에 들어갈 수 있는 최대 수량
	 * 1이면 인벤토리 슬롯 1칸에 1개만 들어감
	 * 주의! MaxSlotStackSize은  MaxInventoryStackSize보다 큰 값을 가질 수 없음!
	 */
	UPROPERTY(EditAnywhere, Category = "Item Numeric Data", meta = (UIMin = 1, UIMax = 999))
	int32 MaxSlotStackSize = -1;

	/**
	* 인벤토리에 소지 가능한 최대 수량
	* 1이면 인벤토리에 1개만 들어감, 0이면 수량 제한 없음
	*/
	UPROPERTY(EditAnywhere, Category = "Item Numeric Data", meta = (UIMin = 0))
	int32 MaxInventoryHoldCount = -1;
	
	UPROPERTY(EditAnywhere, Category = "Item Numeric Data")
	uint8 bIsStackable : 1 = false;	// 인벤토리에 슬롯에 스택이 가능한지
};

USTRUCT()
struct FNAIconAssetData
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, Category = "Item Icon Asset Data")
	TObjectPtr<UTexture2D> ItemIcon = nullptr;

	UPROPERTY(EditAnywhere, Category = "Item Icon Asset Data")
	TObjectPtr<UTexture2D> IxButtonIcon = nullptr;
};

class ANAItemActor;
USTRUCT()
struct ARPG_API FNAItemBaseTableRow : public FTableRowBase
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, Category ="Item Base Data")
	EItemType ItemType = EItemType::IT_None;

	// meta=(BlueprintBaseOnly): 블루프린트 클래스만 노출하도록 강제하는 지정자인데, 5.6 미만에서 버그 있음(언리얼피셜)
	// https://forums.unrealengine.com/t/uproperty-specifier-blueprintbaseonly-is-not-working-this-is-clearly-bug/2334795/6
	// https://issues.unrealengine.com/issue/UE-210088
	// 휴먼 에러 주의(c++ 네이티브 클래스 선택하지 말 것)
	UPROPERTY(EditAnywhere, Category = "Item Base Data", meta=(BlueprintBaseOnly, AllowAbstract="false"))
	TSoftClassPtr<ANAItemActor> ItemClass = nullptr;
	
	// None: 기본 생성자에서 DoNotCreateSubobject로 ItemCollision 생성 수정한 경우!! 반다시!! 이 플래그 써야함
	UPROPERTY(EditAnywhere, Category = "Item Collision Shape")
	EItemCollisionShape CollisionShape = EItemCollisionShape::ICS_None;
	
	UPROPERTY(EditAnywhere, Category = "Item Collision Shape",
		meta=(EditCondition="CollisionShape==EItemCollisionShape::ICS_Sphere", EditConditionHides,ClampMin= "0.0"))
	float CollisionSphereRadius = 0.f;

	UPROPERTY(EditAnywhere, Category = "Item Collision Shape",
			meta=(EditCondition="CollisionShape==EItemCollisionShape::ICS_Box", EditConditionHides, ClampMin= "0.0"))
	FVector CollisionBoxExtent = FVector::ZeroVector;

	UPROPERTY(EditAnywhere, Category = "Item Collision Shape",
			meta=(EditCondition="CollisionShape==EItemCollisionShape::ICS_Capsule", EditConditionHides, ClampMin= "0.0"))
	FVector2D CollisionCapsuleSize = FVector2D::ZeroVector;

	UPROPERTY(EditAnywhere, Category = "Item Collision Shape",
		meta=(EditCondition="CollisionShape!=EItemCollisionShape::ICS_None", EditConditionHides))
	FTransform CollisionTransform = FTransform::Identity;
	
	/* ANAItemActor의 메쉬 타입*/
	// None: 기본 생성자에서 DoNotCreateSubobject로 ItemMesh 생성 수정한 경우!! 반다시!! 이 플래그 써야함
	UPROPERTY(EditAnywhere, Category = "Item Mesh")
	EItemMeshType MeshType = EItemMeshType::IMT_Static;
	
	/** Static Mesh 에셋*/
	UPROPERTY(EditAnywhere, Category = "Item Mesh",
		meta=(EditCondition="MeshType==EItemMeshType::IMT_Static", EditConditionHides))
	FNAStaticMeshItemAssetData StaticMeshAssetData;
	
	/** Skeletal  Mesh  에셋 */
	UPROPERTY(EditAnywhere, Category = "Item Mesh",
		meta=(EditCondition="MeshType==EItemMeshType::IMT_Skeletal", EditConditionHides))
	FNASkeletalMeshItemAssetData SkeletalMeshAssetData;
	
	UPROPERTY(EditAnywhere, Category = "Item Mesh",
		meta=(EditCondition="MeshType!=EItemMeshType::IMT_None", EditConditionHides))
	FTransform MeshTransform = FTransform::Identity;
	
	UPROPERTY(EditAnywhere, Category ="Item Icon")
	FNAIconAssetData IconAssetData;
	
	UPROPERTY(EditAnywhere, Category = "Item Text", meta=(ShowOnlyInnerProperties))
	FItemTextData TextData;

	UPROPERTY(EditAnywhere, Category = "Item Numeric Statics", meta=(ShowOnlyInnerProperties))
	FItemNumericData NumericData;
	
	UPROPERTY(EditAnywhere,/* Category = "Item Interactable Data", */meta=(ShowOnlyInnerProperties))
	FNAInteractableData InteractableData;
	
#if WITH_EDITOR
protected:
	virtual void OnDataTableChanged(const UDataTable* InDataTable, const FName InRowName) override;
#endif
};

USTRUCT()
struct FNADropItemPair
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "MonsterDropTable")
	TSubclassOf<ANAItemActor> ItemClasses;

	UPROPERTY(EditAnywhere, Category = "MonsterDropTable")
	float Probability;
};

// 몬스터당 하나씩		-> monster Status 쪽에 만들어 놓음
USTRUCT()
struct ARPG_API FNATestDropBaseTableRow : public FTableRowBase
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, Category = "Item Base Data", meta=(BlueprintBaseOnly, AllowAbstract="false"))
	TArray<FNADropItemPair> ItemClass;

};

// 우리의 목적: 강화하기

// 강화를 하기 위해서 -> 강화 아이템을 떨궈야겠지?
// 강화 아이템을 떨구기 위해선 몬스터가 드랍을 해야겠지?
// 강화 아이템을 뭘 드랍할지 테이블로 정리
// 몹이 죽으면 테이블 기반으로 확률적으로 돌려서 아이템 뽑고 SpawnActor 후 사망ㄴ

// ----------

// 강화 아이템 드랍 -> 인벤토리로 이동
// 위젯에서 인벤토리 기반으로 강화 아이템 띄워주고
// 위젯에서 강화 아이템이 충분히 있으면 강화 가능, 강화 요청 수행

// ----------

// 강화 => Ability 추가, (예: 중력 줍기)
// 위젯에서 강화 -> 강화에서 노드 강화를 하면
// 노드 강화 -> GAS에서 캡처 -> Ability 부여

----------------------------------------------------------------------------------------------------------------------

## NAItemBaseDataStructs.cpp

#include "Item/ItemDataStructs/NAItemBaseDataStructs.h"
#include "Item/PickableItem/NAWeapon.h"
#include "Item/EngineSubsystem/NAItemEngineSubsystem.h"
#include "Item/ItemActor/NAPlaceableItemActor.h"
#include "Item/PickableItem/NAUpgradeNode.h"
#include "Misc/StringUtils.h"
#include "Item/PickableItem/NAUpgradeNode.h"

#if WITH_EDITOR

void FNAItemBaseTableRow::OnDataTableChanged(const UDataTable* InDataTable, const FName InRowName)
{
	FNAItemBaseTableRow* ItemRowStruct = InDataTable->FindRow<FNAItemBaseTableRow>(InRowName, TEXT("On Data Table Changed"));
	
	if (ItemRowStruct == this)
	{
		if (!ItemRowStruct->ItemClass.IsValid()) return;
		
		if (UNAItemEngineSubsystem::Get()
			&& UNAItemEngineSubsystem::Get()->IsItemMetaDataInitialized())
		{
			UClass* ItemActorClass = ItemRowStruct->ItemClass.Get();
			if (ItemActorClass)
			{
				if (!UNAItemEngineSubsystem::Get()->IsRegisteredItemMetaClass(ItemActorClass))
				{
					UNAItemEngineSubsystem::Get()->RegisterNewItemMetaData(ItemActorClass, InDataTable, InRowName);
				}
				else
				{
					UNAItemEngineSubsystem::Get()->VerifyItemMetaDataRowHandle(ItemActorClass, InDataTable, InRowName);
				}
			}
		}

		if (ItemType == EItemType::IT_Weapon
			|| ItemClass.Get()->IsChildOf<ANAWeapon>())
		{
			NumericData.bIsStackable = false;
			NumericData.MaxSlotStackSize = 1;
			NumericData.MaxInventoryHoldCount = 1;
		}
		else
		{
			if (!NumericData.bIsStackable)
			{
				NumericData.MaxSlotStackSize = 1;
				NumericData.MaxInventoryHoldCount = FMath::Max(0, NumericData.MaxInventoryHoldCount);
			}
			
			if (NumericData.MaxInventoryHoldCount == 0)
			{
				NumericData.MaxSlotStackSize = FMath::Max(0, NumericData.MaxSlotStackSize);
			}
			else if (NumericData.MaxInventoryHoldCount > 0)
			{
				NumericData.MaxSlotStackSize = FMath::Max(1, NumericData.MaxSlotStackSize);
			}
		}
		
		if (!InRowName.IsNone())
		{
			FString NewItemName = FStringUtils::InsertSpacesBeforeUppercaseSmart(InRowName.ToString());
			TextData.Name = FText::FromString(NewItemName);
		}

		if (InteractableData.InteractableType != ENAInteractableType::None)
		{
			FString EnumStr = FStringUtils::EnumToDisplayString(InteractableData.InteractableType);
			EnumStr = FStringUtils::InsertSpacesBeforeUppercaseSmart(EnumStr);
			InteractableData.InteractionName = FText::FromString(EnumStr);
		}

		if (ItemClass.Get()->IsChildOf<ANAPlaceableItemActor>())
		{
			InteractableData.bIsUnlimitedInteractable = true;
			InteractableData.InteractableCount = 0;
		}

		if (ItemClass.Get()->IsChildOf<ANAUpgradeNode>())
		{
			ItemType = EItemType::IT_UpgradeNode;
		}

		if (ItemType == EItemType::IT_Credit || ItemType == EItemType::IT_UpgradeNode)
		{
			NumericData.bIsStackable = true;
			NumericData.MaxSlotStackSize = 0;
			NumericData.MaxInventoryHoldCount = 0;
			
			if (InteractableData.InteractableType == ENAInteractableType::None)
			{
				InteractableData.InteractableType = ENAInteractableType::Pickup;
			}
		}
	}
}
#endif

----------------------------------------------------------------------------------------------------------------------

## NAWeaponDataStructs.h

#pragma once

#include "Item/ItemDataStructs/NAItemBaseDataStructs.h"

#include "NAWeaponDataStructs.generated.h"


class UGameplayAbility;

UENUM(BlueprintType)
enum class EWeaponRarity : uint8
{
	WR_None        UMETA(DisplayName = "None"),        // 초기화 필요

	WR_Common      UMETA(DisplayName = "Common"),      // 일반 (흰색)
	WR_Uncommon    UMETA(DisplayName = "Uncommon"),    // 고급 (녹색)
	WR_Rare        UMETA(DisplayName = "Rare"),        // 희귀 (파란색)
	WR_Epic        UMETA(DisplayName = "Epic"),        // 영웅 (보라색)
	WR_Legendary   UMETA(DisplayName = "Legendary"),   // 전설 (주황색)
	WR_Mythic      UMETA(DisplayName = "Mythic"),      // 신화 (붉은색 혹은 금색)
};

UENUM(BlueprintType)
enum class  EWeaponType : uint8
{
	WT_None        UMETA(Hidden),		// 초기화 필요

	WT_Blunt       UMETA(DisplayName = "Blunt"),      // 둔기: 몽둥이, 망치, 철퇴 등
	WT_Blade       UMETA(DisplayName = "Blade"),      // 예기: 검, 도, 창 등 날붙이
	WT_Firearm     UMETA(DisplayName = "Firearm")     // 총기: 권총, 소총, 산탄총 등
};

UENUM( BlueprintType )
enum class EFireArmType : uint8
{
	FAT_None UMETA( Hidden ),

	FAT_Pistol UMETA( DisplayName = "Pistol" ),
	FAT_Rifle UMETA( DisplayName = "Rifle" )
};

USTRUCT()
struct FNAWeaponStatistics
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Weapon Statistics")
	EWeaponRarity WeaponRarity = EWeaponRarity::WR_Common;

	UPROPERTY(EditAnywhere, Category = "Weapon Statistics")
	float WeaponDamage = 0.0f;

	UPROPERTY(EditAnywhere, Category = "Weapon Statistics")
	float WeaponAttackSpeed = 0.0f;
};

//class ANAProjectile;
USTRUCT()
struct FNAFirearmStatistics 
{
	GENERATED_BODY()

	//UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	//TSubclassOf<ANAProjectile> ProjectileClass;	// 발사체 클래스

	UPROPERTY(EditAnywhere, Category = "Firing Statistics")
	EFireArmType FireArmType = EFireArmType::FAT_None;

	UPROPERTY(EditAnywhere, Category= "Firearm Statistics")
	UAnimMontage* FirearmMontage = nullptr;

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	TSubclassOf<UGameplayAbility> GameplayAbility = nullptr;

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	int32 MaxAmmo = -1;

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	float ReloadTime = 0.0f;

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	float FireRate = 0.0f;	// 초당 발사 수, 연사 속도

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	float BulletSpread = 0.0f;	// 총알 퍼짐 정도

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	float RecoilStrength = 0.0f;	// 반동 강도

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	float EffectiveRange = 0.0f;	// 유효 사거리

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	int32 PierceCount = -1; 	// 관통 수, 총알이 적을 몇 마리 관통할 수 있는지

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	int32 AmmoPerShot = -1; 	// 한 번 발사할 때 소비되는 탄 수

	UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	bool bIsAutomatic = false;	// 자동 발사 여부

	//UPROPERTY(EditAnywhere, Category = "Firearm Statistics")
	//EFireMode FireMode = EFireMode::FM_Single;	// 발사 모드 (단발, 점사, 연사 등)
};

USTRUCT()
struct ARPG_API FNAWeaponTableRow : public FNAItemBaseTableRow
{
	GENERATED_BODY()

	FNAWeaponTableRow();
	
	UPROPERTY(EditAnywhere, Category = "Weapon")
	EWeaponType WeaponType = EWeaponType::WT_None;

	UPROPERTY(EditAnywhere, Category = "Weapon")
	FNAWeaponStatistics WeaponStatistics;

	UPROPERTY(EditAnywhere, Category = "Firearm",
		meta = (EditCondition = "WeaponType==EWeaponType::WT_Firearm", EditConditionHides))
	FNAFirearmStatistics FirearmStatistics;

	UPROPERTY(EditAnywhere, Category = "Weapon")
	FTransform AttachmentTransform;
};

----------------------------------------------------------------------------------------------------------------------

## NARecoveryPackDataStructs.h

// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "Item/ItemDataStructs/NAItemBaseDataStructs.h"
#include "NARecoveryPackDataStructs.generated.h"

UENUM(BlueprintType)
enum class ERecoverableStatType : uint8
{
	RT_None			UMETA(Hidden),
	
	RT_Hp			UMETA(DisplayName = "Hp"),
	RT_Stasis		UMETA(DisplayName = "Stasis"),
	//RT_Mana		UMETA(DisplayName = "Mana"),
	//RT_Shield		UMETA(DisplayName = "Shield"),
	RT_Oxygen		UMETA(DisplayName = "Oxygen"),
};

UENUM(BlueprintType)
enum class EMedPackGrade : uint8
{
	MPG_None			UMETA(Hidden),

	MPG_Small			UMETA(DisplayName = "Small"),
	MPG_Medium			UMETA(DisplayName = "Medium"),
	MPG_Large			UMETA(DisplayName = "Large"),
};


// 회복 팩: 별도의 사용 단축키 존재(인벤 안켜고 단축키로 바로 사용 가능)
USTRUCT()
struct ARPG_API FNARecoveryPackTableRow : public FNAItemBaseTableRow
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, Category = "Recovery")
	ERecoverableStatType RecoveryTargetStat = ERecoverableStatType::RT_Hp;

	UPROPERTY(EditAnywhere, Category = "Recovery",
		meta=(EditCondition="RecoveryTargetStat==ERecoverableStatType::RT_Hp", EditConditionHides))
	EMedPackGrade MedPackGrade = EMedPackGrade::MPG_Small;

	// 회복 수치. 절댓값 기준
	UPROPERTY(EditAnywhere, Category = "Recovery", meta = (ClampMin = "0"))
	float RecoveryAmount = 0.0f;

	UPROPERTY(EditAnywhere, Category = "Recovery", meta = (ClampMin = "0"))
	float RecoveryFactor = 0.f;

	// 비율 기반 회복인지 여부 (true면 최대치의 %로 회복)
	UPROPERTY(EditAnywhere, Category = "Recovery")
	bool bIsPercentRecovery = false;

	// 회복이 즉시 발생하는지 (true) / 지속 회복인지(false)
	UPROPERTY(EditAnywhere, Category = "Recovery")
	bool bIsInstantRecovery = true;

	// 초당 회복량. bIsInstantRecovery가 false일 때 사용
	UPROPERTY(EditAnywhere, Category = "Recovery", meta = (EditCondition = "!bIsInstantRecovery"))
	float RecoveryRate = 0.0f;

	// 지속 시간. 즉시 회복이 아닐 경우에만 의미 있음
	UPROPERTY(EditAnywhere, Category = "Recovery", meta = (EditCondition = "!bIsInstantRecovery"))
	float RecoveryDuration = 0.0f;

	// 상태이상 해제 여부. 예: 중독, 화상 등
	// 상태이상 필요하면 쓰기
	// UPROPERTY(EditAnywhere, Category = "Effect")
	// bool bRemovesNegativeEffects = false;

	// 아이템 사용 후 쿨타임
	// 쿨타임 필요할까??
	// UPROPERTY(EditAnywhere, Category = "Usage")
	// float CooldownAfterUse = 0.0f;

	// 이동 중 사용 가능 여부
	// 필요함??
	// UPROPERTY(EditAnywhere, Category = "Usage")
	// bool bCanBeUsedWhileMoving = true;
};
