## NAItemWidgetComponent.h

// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/WidgetComponent.h"
#include "NAItemWidgetComponent.generated.h"


UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class ARPG_API UNAItemWidgetComponent : public UWidgetComponent
{
	GENERATED_BODY()

public:
	// Sets default values for this component's properties
	UNAItemWidgetComponent(const FObjectInitializer& ObjectInitializer);
	virtual void PostInitProperties() override;

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType,
	                           FActorComponentTickFunction* ThisTickFunction) override;

	virtual void InitWidget() override;

	class UNAItemData* GetItemDataFromOwner() const;
	
	virtual void ReleaseItemWidgetPopup();
	virtual void CollapseItemWidgetPopup();

	class UNAItemWidget* GetItemWidget() const;

	void SetItemInteractionName(const FString& NewString) const;

	void SetEnableUpdateTransform(const bool bEnable);
	
protected:
	virtual void InitItemWidgetClass();
	virtual void InitItemWidgetTransform();
	
	void UpdateTransformFacingCamera();
	void UpdateTransformFacingCharacter();

private:
	uint8 bUpdateTransformFacingCamera : 1 = false;

	// Yaw: 설정 반영 안됨(카메라 빌보드 처리)
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	FRotator PickableWidgetRelativeRotation = FRotator::ZeroRotator;
	
	// X: 앞/뒤  Y: 좌/우  Z: 상/하
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	FVector PickableWidgetRelativeOffset = FVector::ZeroVector;

	
	uint8 bUpdateTransformFacingCharacter : 1 = false;
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	FTransform PlaceableWidgetRelativeForwardTransform = FTransform::Identity;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	FTransform PlaceableWidgetRelativeBackwardTransform = FTransform::Identity;

	UPROPERTY(EditAnywhere, meta = (AllowPrivateAccess = "true"))
	TSoftClassPtr<UNAItemWidget> ItemWidgetClass;

protected:
	UPROPERTY(EditAnywhere)
	TSoftClassPtr<class UNAItemWidget> PickableItemWidgetClassRef;
	UPROPERTY(EditAnywhere)
	TSoftClassPtr<class UNAItemWidget> PlaceableItemWidgetClassRef;

	UPROPERTY(EditAnywhere)
	TSoftObjectPtr<UMaterialInterface> ItemWidgetMaterialRef;
};

----------------------------------------------------------------------------------------------------------------------

## NAItemWidgetComponent.cpp

// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/ItemWidget/NAItemWidgetComponent.h"

#include "Item/ItemActor/NAPickableItemActor.h"
#include "Item/ItemActor/NAPlaceableItemActor.h"
#include "Item/ItemWidget/NAItemWidget.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetMathLibrary.h"

// Sets default values for this component's properties
UNAItemWidgetComponent::UNAItemWidgetComponent(const FObjectInitializer& ObjectInitializer)
	:Super(ObjectInitializer)
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = true;

	SetCollisionEnabled(ECollisionEnabled::NoCollision);
	SetGenerateOverlapEvents(false);
	SetEnableGravity(false);
	CanCharacterStepUpOn = ECB_No;
	SetSimulatePhysics(false);
	bApplyImpulseOnDamage = false;
	bReplicatePhysicsToAutonomousProxy = false;
	BodyInstance.SetInertiaConditioningEnabled(false);
	BodyInstance.bGenerateWakeEvents = false;
	BodyInstance.bUpdateMassWhenScaleChanges = false;

	SetWidgetSpace(EWidgetSpace::World);
	SetGeometryMode(EWidgetGeometryMode::Plane);
	OpacityFromTexture = 1.f;
	SetBlendMode(EWidgetBlendMode::Masked);
	SetWindowFocusable(false);

	static const FSoftClassPath PickableItemWidgetClassPath(TEXT("/Game/00_ProjectNA/01_Blueprint/01_Widget/Item/BP_NAPickableItemDefaultWidget.BP_NAPickableItemDefaultWidget_C"));
	PickableItemWidgetClassRef = PickableItemWidgetClassPath;
	
	static const FSoftClassPath PlaceableItemWidgetClassPath(TEXT("/Game/00_ProjectNA/01_Blueprint/01_Widget/Item/BP_NAPlaceableItemDefaultWidget.BP_NAPlaceableItemDefaultWidget_C"));
	PlaceableItemWidgetClassRef = PlaceableItemWidgetClassPath;

	static const FSoftObjectPath ItemWidgetMaterialPath(TEXT("/Game/00_ProjectNA/01_Blueprint/01_Widget/Item/Materials/M_ItemWidgetDefault.M_ItemWidgetDefault"));
	ItemWidgetMaterialRef = ItemWidgetMaterialPath;
}

void UNAItemWidgetComponent::PostInitProperties()
{
	Super::PostInitProperties();

	InitItemWidgetClass();
	InitItemWidgetTransform();
}

void UNAItemWidgetComponent::InitItemWidgetClass()
{
	if (GetOwner() && GetWidgetClass() == nullptr)
	{
		if (GetOwner()->GetClass()->IsChildOf<ANAPickableItemActor>())
		{
			if (PickableItemWidgetClassRef.IsNull()) return;
			
			SetWidgetClass(PickableItemWidgetClassRef.LoadSynchronous());
		}
		else if (GetOwner()->GetClass()->IsChildOf<ANAPlaceableItemActor>())
		{
			if (PlaceableItemWidgetClassRef.IsNull()) return;
			SetWidgetClass(PlaceableItemWidgetClassRef.LoadSynchronous());
		}
	}
}

void UNAItemWidgetComponent::InitItemWidgetTransform()
{
	if (!GetWidgetClass()) return;
	
	if (GetOwner()->GetClass()->IsChildOf<ANAPickableItemActor>())
	{
		PickableWidgetRelativeOffset = FVector(0.f, 80.f, 170.f);
		SetRelativeLocation(PickableWidgetRelativeOffset);

		PickableWidgetRelativeRotation = FRotator(10.f, 180.0f, 0.0f);
		SetRelativeRotation(PickableWidgetRelativeRotation);

		SetRelativeScale3D(FVector(0.4f));
		SetDrawSize(FVector2D(340, 410));
	}
	else if (GetOwner()->GetClass()->IsChildOf<ANAPlaceableItemActor>())
	{
		FVector ForwardLoc = FVector(80.f, 0.f, 0.f);
		FRotator ForwardRot = FRotator(0.f, 0.f, 0.f);

		FVector BackwardLoc = FVector(-80.f, 0.f, 0.f);
		FRotator BackwardRot = FRotator(0.f, 180.f, 0.f);

		PlaceableWidgetRelativeForwardTransform.SetLocation(ForwardLoc);
		PlaceableWidgetRelativeForwardTransform.SetRotation(ForwardRot.Quaternion());

		PlaceableWidgetRelativeBackwardTransform.SetLocation(BackwardLoc);
		PlaceableWidgetRelativeBackwardTransform.SetRotation(BackwardRot.Quaternion());

		SetRelativeTransform(PlaceableWidgetRelativeBackwardTransform);

		SetDrawSize(FVector2D(260, 50));
	}
}

// Called when the game starts
void UNAItemWidgetComponent::BeginPlay()
{
	Super::BeginPlay();

	// SetMaterial은 어느 시점에서 불러도 렌더러를 요구
	SetMaterial(0, ItemWidgetMaterialRef.LoadSynchronous());
	SetVisibility(false);
	Deactivate();
}


// Called every frame
void UNAItemWidgetComponent::TickComponent(float DeltaTime, ELevelTick TickType,
                                           FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	if (bUpdateTransformFacingCamera)
	{
		UpdateTransformFacingCamera();
	}
	if (bUpdateTransformFacingCharacter)
	{
		UpdateTransformFacingCharacter();
	}
}

void UNAItemWidgetComponent::InitWidget()
{
	Super::InitWidget();
	
	if (GetWorld()->IsPreviewWorld()) return;
	if (!GetItemDataFromOwner()) return;
	
	if (GetItemWidget())
	{
		GetItemWidget()->InitItemWidget(this, GetItemDataFromOwner());
	}
}

UNAItemData* UNAItemWidgetComponent::GetItemDataFromOwner() const
{
	if (ANAItemActor* ItemActor = Cast<ANAItemActor>(GetOwner()))
	{
		return ItemActor->GetItemData();
	}
	return nullptr;
}

void UNAItemWidgetComponent::ReleaseItemWidgetPopup()
{
	if (GetWorld()->IsPreviewWorld()) return;
	if (!GetItemDataFromOwner()) return;

	GetItemWidget()->ReleaseItemWidget();
}

void UNAItemWidgetComponent::CollapseItemWidgetPopup()
{
	if (GetWorld()->IsPreviewWorld()) return;
	if (!GetItemDataFromOwner()) return;

	GetItemWidget()->CollapseItemWidget();
}

void UNAItemWidgetComponent::SetItemInteractionName(const FString& NewString) const
{
	if (GetItemWidget())
	{
		GetItemWidget()->SetInteractionNameText(NewString);
	}
}

void UNAItemWidgetComponent::SetEnableUpdateTransform(const bool bEnable)
{
	if (GetOwner()->GetClass()->IsChildOf<ANAPickableItemActor>())
	{
		bUpdateTransformFacingCharacter = false;
		bUpdateTransformFacingCamera = bEnable;
		if (bUpdateTransformFacingCamera)
		{
			UpdateTransformFacingCamera();
		}
	}
	else if (GetOwner()->GetClass()->IsChildOf<ANAPlaceableItemActor>())
	{
		bUpdateTransformFacingCamera = false;
		bUpdateTransformFacingCharacter = bEnable;
		if (bUpdateTransformFacingCharacter)
		{
			UpdateTransformFacingCharacter();
		}
	}
}

class UNAItemWidget* UNAItemWidgetComponent::GetItemWidget() const
{
	return Cast<UNAItemWidget>(GetWidget());
}

void UNAItemWidgetComponent::UpdateTransformFacingCamera()
{
	if (!bUpdateTransformFacingCamera) return;
	
	int32 PlayerIndex = GetOwnerPlayer()->GetLocalPlayerIndex();
	APlayerCameraManager* PCM = UGameplayStatics::GetPlayerCameraManager(this, PlayerIndex);
	if (!PCM) return;
	
	FVector ToCameraLoc = PCM->GetCameraLocation() - GetComponentLocation();
	FRotator LookAtRot = UKismetMathLibrary::MakeRotFromX(ToCameraLoc);
	LookAtRot.Pitch = PickableWidgetRelativeRotation.Pitch;
	LookAtRot.Roll = PickableWidgetRelativeRotation.Roll;
	
	SetWorldRotation(LookAtRot);

	FVector RootWorldLoc = GetAttachParent()->GetComponentLocation();
	const FRotator CameraRot = PCM->GetCameraRotation();
	
	const FVector CameraForward = CameraRot.Quaternion().GetForwardVector();
	const FVector CameraRight = CameraRot.Quaternion().GetRightVector();
	const FVector CameraUp = CameraRot.Quaternion().GetUpVector();

	FVector WidgetWorldLoc = RootWorldLoc
		+ (CameraForward * PickableWidgetRelativeOffset.X)
		+ (CameraRight * PickableWidgetRelativeOffset.Y)
		+ (CameraUp * PickableWidgetRelativeOffset.Z);

	SetWorldLocation(WidgetWorldLoc);
}

void UNAItemWidgetComponent::UpdateTransformFacingCharacter()
{
	if (!GetAttachParent()) return;

	// 1. 루트(부모) 위치, Forward 벡터
	const FVector RootLoc = GetAttachParent()->GetComponentLocation();
	const FVector RootForward = GetAttachParent()->GetForwardVector();

	// 2. 캐릭터(플레이어) 위치 구하기
	APlayerController* PC = GetOwnerPlayer()->GetPlayerController(GetWorld());
	APawn* PlayerPawn = PC ? PC->GetPawn() : nullptr;
	if (!PlayerPawn) return;
	const FVector CharacterLoc = PlayerPawn->GetActorLocation();

	// 3. 루트 기준 캐릭터가 앞에 있는지, 뒤에 있는지 판정
	const FVector ToCharacter = (CharacterLoc - RootLoc).GetSafeNormal();
	float Dot = FVector::DotProduct(RootForward, ToCharacter); // >0: 앞, <0: 뒤

	FVector WidgetOffset;
	FQuat WidgetQuat;

	if (Dot > 0.f)
	{
		// 캐릭터가 루트의 "앞"에 있음
		WidgetOffset = PlaceableWidgetRelativeForwardTransform.GetLocation();
		WidgetQuat = PlaceableWidgetRelativeForwardTransform.GetRotation();
	}
	else
	{
		// 캐릭터가 루트의 "뒤"에 있음
		WidgetOffset = PlaceableWidgetRelativeBackwardTransform.GetLocation();
		WidgetQuat = PlaceableWidgetRelativeBackwardTransform.GetRotation();
	}

	// 4. 루트 위치 + 오프셋(루트의 로컬 -> 월드 변환)
	FVector WidgetWorldLoc = RootLoc + GetAttachParent()->GetComponentTransform().TransformVectorNoScale(WidgetOffset);
	SetWorldLocation(WidgetWorldLoc);

	// 5. 루트의 월드 회전에 오프셋 회전 합성
	FQuat RootQuat = GetAttachParent()->GetComponentQuat();
	FQuat WorldQuat = WidgetQuat * RootQuat; // 오프셋 -> 루트 회전

	SetWorldRotation(WorldQuat);
}

----------------------------------------------------------------------------------------------------------------------

## NAItemWidget.h

// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "NAItemWidget.generated.h"

DECLARE_DELEGATE(FOnItemWidgetCollapseFinishedForDestroy);

UCLASS()
class ARPG_API UNAItemWidget : public UUserWidget
{
	GENERATED_BODY()

	friend class UNAItemWidgetComponent;
protected:
	// CreateWidget으로 위젯 인스턴스가 생성되고 나서 호출됨
	virtual void NativeOnInitialized() override;
	virtual void NativeConstruct() override;
	virtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override;
	
	UFUNCTION(BlueprintCallable, Category = "Item Widget")
	virtual void OnItemWidgetReleased();
	UFUNCTION(BlueprintCallable, Category = "Item Widget")
	virtual void OnItemWidgetCollapsed();
	
	void SetInteractionNameText(const FString& NewString) const;
	
public:
	virtual void InitItemWidget(UNAItemWidgetComponent* OwningComp, class UNAItemData* ItemData);
	
	virtual void ReleaseItemWidget();
	virtual void CollapseItemWidget();

public:
	FOnItemWidgetCollapseFinishedForDestroy OnItemWidgetCollapseFinishedForDestroy;
	
protected:
	UPROPERTY(Transient, BlueprintReadOnly)
	uint8 bReleaseItemWidget : 1 = false;
	
	UPROPERTY(Transient, BlueprintReadOnly)
	TWeakObjectPtr<UNAItemWidgetComponent> OwningItemWidgetComponent;
	
// Widget Animations ////////////////////////////////////////////////////////////////////////////////////////////////
	UPROPERTY(Transient, BlueprintReadOnly, meta = (BindWidgetAnimOptional), Category = "Widget Animation")
	TObjectPtr<UWidgetAnimation> Widget_Appear;

	UPROPERTY(Transient, BlueprintReadOnly, meta = (BindWidgetAnimOptional), Category = "Widget Animation")
	TObjectPtr<UWidgetAnimation> Widget_VisibleLoop;
	
// Widget Bindings ////////////////////////////////////////////////////////////////////////////////////////////////	
	UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta = (BindWidgetOptional), Category = "Item Widget")
	TObjectPtr<class UTextBlock> Item_Name;

	UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta = (BindWidgetOptional), Category = "Item Widget")
	TObjectPtr<class UImage> Item_Icon;

	UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta = (BindWidgetOptional), Category = "Item Widget")
	TObjectPtr<UTextBlock> Item_Type;

	UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, meta = (BindWidgetOptional), Category = "Item Widget")
	TObjectPtr<UTextBlock> Interaction_Name;
};

----------------------------------------------------------------------------------------------------------------------

## NAItemWidget.cpp

// Fill out your copyright notice in the Description page of Project Settings.


#include "Item/ItemWidget/NAItemWidget.h"

#include "Components/Image.h"
#include "Components/TextBlock.h"
#include "Item/ItemWidget/NAItemWidgetComponent.h"
#include "Item/ItemData/NAItemData.h"
#include "Misc/StringUtils.h"

void UNAItemWidget::NativeOnInitialized()
{
	Super::NativeOnInitialized();
}

void UNAItemWidget::NativeConstruct()
{
	Super::NativeConstruct();
	SetIsFocusable(false);
	ForceLayoutPrepass();
	SetVisibility(ESlateVisibility::Collapsed);
}

void UNAItemWidget::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)
{
	Super::NativeTick(MyGeometry, InDeltaTime);
}

void UNAItemWidget::ReleaseItemWidget()
{
	if (!OwningItemWidgetComponent.IsValid()) return;
	
	bReleaseItemWidget = true;
	
	if (Widget_Appear)
	{
		PlayAnimationForward(Widget_Appear, 1.5f);
	}
}

void UNAItemWidget::OnItemWidgetReleased()
{
	if (bReleaseItemWidget)
	{
		if (Widget_VisibleLoop)
		{
			PlayAnimation(Widget_VisibleLoop, 0.f, 0);
		}
	}
	else
	{
		if (Widget_VisibleLoop)
		{
			StopAnimation(Widget_VisibleLoop);
		}
	}
}

void UNAItemWidget::CollapseItemWidget()
{
	if (!OwningItemWidgetComponent.IsValid()) return;
	
	bReleaseItemWidget = false;
	if (Widget_Appear)
	{
		PlayAnimationReverse(Widget_Appear, 1.8f);
	}
}

void UNAItemWidget::OnItemWidgetCollapsed()
{
	if (bReleaseItemWidget)
	{
		OwningItemWidgetComponent->Activate();
		OwningItemWidgetComponent->SetVisibility(true);
		OwningItemWidgetComponent->SetWindowVisibility(EWindowVisibility::Visible);
		OwningItemWidgetComponent->SetEnableUpdateTransform(true);
		
		SetIsEnabled(true);
		SetVisibility(ESlateVisibility::HitTestInvisible);
	}
	else
	{
		SetVisibility(ESlateVisibility::Hidden);
		SetIsEnabled(false);

		OwningItemWidgetComponent->SetEnableUpdateTransform(false);
		OwningItemWidgetComponent->SetWindowVisibility(EWindowVisibility::SelfHitTestInvisible);
		OwningItemWidgetComponent->SetVisibility(false);
		OwningItemWidgetComponent->Deactivate();
	
		OnItemWidgetCollapseFinishedForDestroy.ExecuteIfBound();
	}
}

void UNAItemWidget::SetInteractionNameText(const FString& NewString) const
{
	if (NewString.IsEmpty()) return;

	Interaction_Name->SetText(FText::FromString(NewString));
}

void UNAItemWidget::InitItemWidget(UNAItemWidgetComponent* OwningComp, UNAItemData* ItemData)
{
	check(OwningComp != nullptr);
	check(ItemData != nullptr);

	OwningItemWidgetComponent = OwningComp;
	
	if (Item_Name)
	{
		Item_Name->SetText(FText::FromString(ItemData->GetItemName()));
	}
	if (Item_Icon)
	{
		Item_Icon->SetBrushResourceObject(ItemData->GetItemIcon());
	}
	if (Item_Type)
	{
		FString ItemTypeStr = FStringUtils::EnumToDisplayString(ItemData->GetItemType());
		ItemTypeStr.RemoveFromStart("IT_");
		ItemTypeStr = FStringUtils::InsertSpacesBeforeUppercaseSmart(ItemTypeStr);
		Item_Type->SetText(FText::FromString(ItemTypeStr));
	}
	if (Interaction_Name)
	{
		FNAInteractableData InteractableData;
		if (ItemData->GetInteractableData(InteractableData))
		{
			Interaction_Name->SetText(InteractableData.InteractionName);
		}
	}
}
