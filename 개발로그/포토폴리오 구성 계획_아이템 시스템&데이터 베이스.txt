### 포트폴리오 구성 계획: 아이템 시스템 & 데이터베이스

---

#### 슬라이드 1: 시스템 개요 및 설계 철학

* 시각 자료: 아이템 시스템 전체 아키텍처 다이어그램 (간략화된 상위 레벨)
* 키워드: `Data-Driven Design`, `Actor-Data 분리`, `책임 분리`
* 요약:
    * 데이터 기반 구조 (Data-Driven Design): 코드 변경 없이 데이터 테이블만으로 아이템 추가 및 수정 가능 
    * Actor-Data 분리 설계: 게임 월드 내 시각적 표현/상호작용(Actor)과 순수 데이터/상태(Data)의 명확한 분리 
    * 아이템 시스템의 책임과 적용 범위: 아이템 생성, 관리, 상태 전이, 상호작용 연동 담당

---

#### 슬라이드 2: 핵심 아키텍처: `ANAItemActor` & `UNAItemData`

* 시각 자료: `ANAItemActor`와 `UNAItemData` 간의 관계 다이어그램 (포인터 참조, 데이터 소유권 등 명시)
* 키워드: `Unreal Actor`, `UObject`, `런타임 상태`, `메타데이터 참조`
* 요약:
    * `ANAItemActor`: 월드에 배치되는 아이템의 시각적 표현, 물리, 충돌, 상호작용 인터페이스 제공 
    * `UNAItemData`: 아이템의 런타임 상태(내구도, 스택 수량 등) 및 `DataTable`의 메타데이터 참조를 위한 `UObject` 
    * 아이템 데이터 ID 및 수량/상태 관리: 각 아이템의 고유 ID를 통해 `UNAItemData`를 식별하고, 수량 및 내구도와 같은 런타임 상태 관리 방식 설명 

---

#### 슬라이드 3: 아이템 시스템의 백본: `UNAItemEngineSubsystem`

* 시각 자료: `DataTable` 로딩 및 `UNAItemData` 매핑 흐름도
* 키워드: `EngineSubsystem`, `DataTable`, `CDO 동기화`, `데이터 매핑`
* 요약:
    * `UNAItemEngineSubsystem`: 엔진 초기화 시점에 아이템 메타데이터를 로딩하고 관리하는 `Subsystem` 활용 
    * `DataTable` 기반 메타데이터 로딩 및 매핑: CSV/JSON 형식의 `DataTable`을 활용하여 아이템 정보를 일괄 로딩하고, `FItemDataRow` 구조체로 매핑 
    * 클래스 ↔ 데이터 행 연결 구조: 아이템 클래스(Blueprint)와 `DataTable`의 데이터 행을 ID를 통해 연결하는 방식 
    * CDO 동기화 및 동적 초기화 흐름: `Class Default Object (CDO)`를 활용한 데이터 초기화 및 런타임 시 동적 데이터 초기화 전략 

---

#### 슬라이드 4: 아이템 액터 타입 구조: Pickable / Placeable

* 시각 자료: 아이템 액터 상속 구조 다이어그램 (Base -> Pickable/Placeable)
* 키워드: `책임 기반 분리`, `컴포넌트 통합`, `상호작용 확장성`
* 요약:
    * 책임 기반 구조 분리:
        * `APickableItemActor`: 인벤토리 획득 및 관리(Inventory-centric)에 중점 
        * `APlaceableItemActor`: 월드 배치 및 환경 상호작용(Environment-centric)에 중점 
    * 공통 기반 클래스에서의 공통 컴포넌트 통합 전략: `ANAItemActor`에 공통으로 필요한 Mesh, Collision 컴포넌트 등을 구성하여 중복 방지 
    * 구조적 구분이 상호작용 시스템 확장에 미치는 영향: 각 타입별 고유 상호작용 방식 정의 및 향후 새로운 아이템 타입 추가 시 유연한 확장성 확보  (상세 동작은 상호작용 프레임워크 섹션 참조 )

---

#### 슬라이드 5: 아이템 액터 생성 흐름 (고민 해결 제안)

* 시각 자료: 아이템 생성 요청부터 액터 스폰 및 데이터 초기화까지의 상세 흐름도
* 키워드: `팩토리 패턴`, `Subsystem`, `데이터 주입`, `액터 풀링 (선택 사항)`
* 요약:
    * 아이템 생성 요청: 인벤토리 시스템, 월드 드롭 등 다양한 경로에서 아이템 생성을 요청.
    * `UNAItemEngineSubsystem` 활용: `UNAItemEngineSubsystem`에 아이템 생성 요청을 위임하여 중앙에서 관리.
    * 데이터 기반 스폰: `UNAItemData`의 `ItemClass` 정보를 활용하여 해당 아이템의 `ANAItemActor` Blueprint 클래스 스폰.
    * 데이터 주입 및 초기화: 스폰된 `ANAItemActor`에 `UNAItemData` 인스턴스를 주입하여 초기화 및 `CDO` 동기화.
    * 액터 풀링 (선택 사항, 고려해볼 점): 아이템 드롭/획득이 빈번한 경우, 액터 생성/파괴 비용 절감을 위해 풀링 시스템 적용을 고려했음. (구현 여부에 따라 기재)

---

#### 슬라이드 6: 아이템 시스템과 상호작용 시스템의 연동 구조

* 시각 자료: 아이템 시스템과 상호작용 시스템 간 인터페이스 기반 연동 다이어그램
* 키워드: `인터페이스 기반 설계`, `책임 위임`, `의존성 역전`
* 요약:
    * 인터페이스 기반 설계: `INAInteractableInterface`, `INAItemUseInterface`와 같은 인터페이스를 통해 시스템 간 느슨한 결합 달성.
    * 아이템 액터 내부에서 상호작용 조건 판별: 아이템 액터 자체는 상호작용 가능한지 여부(예: 거리가 충분한지)만 판별.
    * 로직 실행 외부 위임: 실제 상호작용 로직(예: 아이템 획득, 사용)은 플레이어 컨트롤러 등 외부 시스템으로 위임하여 아이템 액터의 책임을 최소화.
    * 시스템 간 의존성 방향 요약: 아이템 시스템은 상호작용 시스템에 의존하지 않고, 상호작용 시스템이 아이템 시스템의 인터페이스를 활용하는 방향으로 설계.

---

#### 슬라이드 7: 위젯 연동 및 시각 피드백 처리

* 시각 자료: `UNAItemWidgetComponent` 구성 및 3D UI 렌더링 예시 스크린샷
* 키워드: `WidgetComponent`, `3D UI`, `상호작용 피드백`
* 요약:
    * `UNAItemWidgetComponent`의 구성과 역할: 월드 공간에 아이템 이름, 수량 등 정보 표시를 위한 `WidgetComponent` 활용.
    * 위젯의 위치/회전 처리 및 3D UI 피드백 설계: 카메라 시점에 따른 `WidgetComponent`의 위치 및 회전 조정 로직 설명.
    * 상호작용 피드백 애니메이션 트리거 방식 요약: 아이템 획득 시 애니메이션, 이펙트 등 시각적 피드백 처리 방식.

---

#### 슬라이드 8: 아이템 상태 전이 및 액터 복제 처리

* 시각 자료: Drop / Attach / Inventory 전이 과정에서의 데이터 마이그레이션 흐름도
* 키워드: `데이터 마이그레이션`, `ChildActorComponent`, `액터 재사용`
* 요약:
    * `MigrateItemStateTo/FromChildActor` 구조: 아이템이 인벤토리로 들어가거나 월드에 드롭될 때, `ANAItemActor`와 `UNAItemData` 간의 상태 데이터 이동 처리.
    * Drop / Attach / Inventory 전이 과정에서의 데이터 마이그레이션 처리:
        * Drop: `UNAItemData`를 기준으로 `ANAItemActor`를 스폰하고 데이터 주입.
        * Attach/Inventory: `ANAItemActor`를 `ChildActorComponent`로 전환하거나 파괴 후 `UNAItemData`만 인벤토리에 저장.
    * 액터 재사용 또는 파괴 조건 처리 방식: 상황에 따라 액터를 재활용하거나 (풀링) 파괴하는 기준 및 로직 설명.

---

#### 슬라이드 9: 커스터마이징 및 확장성 고려

* 시각 자료: 열거형(EItemType, EPickupMode) 활용 예시 코드 스니펫
* 키워드: `열거형 기반 확장`, `디자이너 설정`, `유지보수성`
* 요약:
    * 열거형 기반 확장 구조: `EItemType`, `EPickupMode`와 같은 열거형을 사용하여 새로운 아이템 타입이나 획득 방식을 쉽게 추가할 수 있도록 설계.
    * 디자이너 설정 가능 항목과 그 분리 위치: `DataTable` 또는 Blueprint `Default` 값을 통해 디자이너가 직접 아이템 속성을 설정할 수 있도록 분리한 부분 강조.
    * 신규 아이템 추가 시 최소 변경 지점 정리: 새로운 아이템 추가 시 코드 변경 없이 데이터 테이블 및 Blueprint만으로 추가 가능함을 강조.

---

#### 슬라이드 10: 최적화 및 유지보수 전략

* 시각 자료: Stub 루트 컴포넌트 구조 다이어그램, FName 기반 참조 코드 예시
* 키워드: `Stub Root Component`, `GC-safe`, `FName 참조`
* 요약:
    * Stub 루트 컴포넌트 구조: `ANAItemActor`의 루트 컴포넌트를 `USceneComponent`와 같은 경량 컴포넌트로 설정하여 생성 시 부하 최소화 및 구조 안정화.
    * 동적 서브오브젝트 구성 최소화 및 동기화 문제 대응: 런타임에 동적으로 생성되는 `UObject`의 수를 최소화하고, 필요한 경우 명확한 생명 주기 관리 및 동기화 전략 수립.
    * `FName` 기반 참조 및 GC-safe 핸들 구조: 문자열 비교 및 `Garbage Collection`에 안전한 `FName`을 활용한 리소스 참조 방식 설명.

---

#### 슬라이드 11: 회고 및 개선 방향

* 시각 자료: 블루프린트 CDO 동기화 이슈 예시 (선택 사항), 구조 파편화 해결 방안 다이어그램
* 키워드: `CDO 동기화 이슈`, `구조 파편화`, `커스텀 툴`
* 요약:
    * 블루프린트 CDO 동기화 이슈와 해결 전략: Blueprint의 `CDO`와 런타임 데이터 간의 동기화 문제 발생 시점 및 해결 경험 공유.
    * 에디터 환경에서 발생한 구조 파편화 문제: 개발 과정에서 발생할 수 있는 데이터 또는 구조 파편화 문제와 이를 방지하기 위한 노력.
    * 추후 개선 방향 및 커스텀 툴 도입 가능성: 아이템 에디터, 데이터 유효성 검사 툴 등 생산성 향상을 위한 커스텀 툴 도입 고려 사항 언급.

---

추가 조언:

* 각 슬라이드별 핵심 메시지: 각 슬라이드의 제목과 요약을 통해 지원자가 강조하고자 하는 핵심 기술과 역량을 명확히 드러내세요.
* 시각 자료의 중요성: 모든 슬라이드에 적절한 다이어그램, 표, 코드 스니펫, 에디터 스크린샷 등을 포함하여 내용을 시각적으로 효과적으로 전달해야 합니다. 특히 아이템 생성 흐름은 흐름도로 표현하는 것이 매우 효과적입니다.
* 간결한 설명: 프레젠테이션 슬라이드이므로, 각 요약은 간결하고 핵심적인 키워드 중심으로 작성하여 청중이 빠르게 이해할 수 있도록 합니다.
* "디자이너도 이해할 수 있는 수준": 복잡한 기술 용어는 간단한 주석이나 비유를 통해 설명하여 비기술 직군도 내용을 이해할 수 있도록 배려합니다.

