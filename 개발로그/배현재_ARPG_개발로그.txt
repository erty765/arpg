[Main Issue]  상호작용 기능 | 인벤토리 기능 & 아이템 활용 기능 & 아이템 DT 관리 | 무기(attack, fire, reload) 기능

[05/13]
◎ 에셋 리스트 작성: 유효한/호환 가능한 에셋 추리고, 필요한 에셋만 다시 검토해야 함
◎ 상호작용 기능 구현 로드맵: 인터페이스 및 Component를 활용하여 모듈화
└ INAInteraction(UInteraction): '상호작용' 기능에 대한 모듈화를 담당, Component 외 다른 계열의 클래스에서도 상호작용 기능이 필요할 때 사용할 수 있어야 함
└ UNAInteractionComponent:
◎ 아이템 인벤토리부터 구현하기!!

[05/14]
◎ 인벤토리 시스템 구현하기 01: 아이템 데이터 만들기 -> 데이터 테이블로 관리
◎ FItemBaseTableRow: 아이템 DT 기반 
◎ 상호작용, 아이템 트리거 박스, 인벤토리에 stack하는 기능: 인터페이스로 빼기?
◎ ANAItemBase에 INAInteraction 구현하기, 아이템 트리거 범위 설정을 위한 UShpereComponent 추가해서 루트로 만들기 -> 이건 선택 가능하도록?
◎ 줍기 가능한 아이템이 있다면 -> ex "E"(줍기) 위젯 계속 띄워두기 (아이템마다 줍기 위젯 설정 x, 유저의 줍기 범위 내 줍기 가능한 아이템이 하나라도 있다면! 줍기 위젯 1개를 계속 띄우기, -> 그렇다면 아이템을 줍기 탐지 범위를 탐색하는 것은 유저 캐릭터에게 넘기기?)
└ 줍기 및 상호작용 가능한 아이템이 활성화되었을 때, 이를 표시하는 위젯은 유저의 화면에서 처리, HUD에서 처리하기 (ex 줍기 가능한 범위 내에서 줍기 위젯 활성, 문처럼 고정된 오브젝트에 상호작용이 활성화된 동안 등)
◎ 소비아이템: ANAConsumableItem : public ANAItemBase
└ 소비아이템에 오브젝트 풀 필요한가..? 고민해보기
◎ 탄약: 소비아이템 소속. 하지만 무기 쪽하고도 연관있음...
└ ANAProjectile: 오브젝트 풀 사용해야함. 근데 오브젝트 풀을 어디에 두지??

※※ 아이템 액터들 콜리전 설정 아직 안함!!! 프로파일 만들고 따로 설정해주기 ※※
[05/16]
아이템 서브시스템 [UNAItemGameInstanceSubsystem]:
└ UItemDataTablesAsset: 아이템 DT를 싹 취합하는 용도로 쓸 예정. UItemDataTablesAsset 데이터 에셋 파일 하나 만들어서, 해당 파일에 아이템 DT 파일들 싹 넣어두기.
└ UNAItemGameInstanceSubsystem::Initialize 단계에서 실행되는 것:
   1) (경로 하드코딩된) UItemDataTablesAsset 파일 동기 로드해서 ItemDataTableSources에 아이템DT 파일 포인터 저장
   2) ItemDataTableSources의 모든 요소의  Row를 순환해서 ItemMetaDataMap 초기화

└ ItemMetaDataMap: 아이템 메타데이터 맵핑용, UClass-DTRowHandle, 클래스로 키값 검색 가능하기 때문에 BP 클래스에 대응 가능
└ 일반 AActor 계열의 객체에서 (CDO 제외) ItemMetaDataMap에 접근하려면 PostInitProperties 호출 시점부터 접근하는걸 추천.
아이템 DT [FNAItemBaseDataTable]: 이거 상속받아서 아이템 DT 세분화 (e.g. FWeaponDataTableRow)
아이템 데이터/껍데기 [UNAItemData/ANAItemInstance]:
└ UNAItemData: final. 아이템에 대한 [가변 데이터 + 메타 데이터]를 아이템 인스턴스별로 관리하기 위한 클래스. ANAItemInstance에 소유됨
└ ANAItemInstance: 아이템의 시각적 구현 담당. ㄹㅇ 껍데기용. (나중에 오브젝트 풀 사용한 최적화 적용할까 고민중) 상호작용 인터페이스 상속시킬 예정. (CDO제외) PostInitProperties 때 UNAItemData 유효성 검사하고 null이면 아이템 서브시스템이 관리하는 아이템 메타데이터 맵에서 아이템 메타 데이터 가져와서 UNAItemData 초기화

◎ NAItemInstance에서 InitItemData 로직 흐름 구성중

[05/18]
◎ UNAItemData, ANAItemInstance 로직 정리 완료
◎ 상호작용 != 아이템 사용: 기능 분리
└ 상호작용: 아이템 인스턴스(껍데기)가 활성화될 때 발생 -> 유저의 인벤토리에 소지된 아이템은 상호작용 X
└ 아이템 사용: 아이템 데이터를 경유하여 발생 -> 아이템 사용으로 인해 아이템 데이터가 바뀜(수량, 상태 등)
	└ 그렇다면 물약을 마시는 행위는? 아이템 사용: 물약 효과가 캐릭터에 적용, 물약 마시는 애니메이션이 있다면 -> 해당 아이템 인스턴스를 release해서 메쉬 시각화(물약 마시는 애니메이션은 캐릭터 쪽에서 처리)
└ 상호작용은 INAInteraction 인터페이스로
└ 아이템 사용은 UNAItemData의 메서드 활용: UNAItemData에 TWeakObjectPtr<T>로 해당 아이템을 소지 중인 객체 추적(Outer 개념x)
◎ ANAPickableItemInstance ->ANAStackableItemInstance: 인벤토리에 여러 개 쌓을 수 있는? 월드에 소환되어 유저의 인벤토리에 복사되는 아이템들. 예를 들면, 일정 시간마다 월드에 리젠될 때마다 계속 주울 수 있는 아이템 

[05/19]
◎ ANAItemInstance: UNAInteraction 구현
└ 구체적인 동작 수행 로직은x(이건 자식 클래스에서 구체화)
└ 유저에게 상호작용 요청을 받아서 상호작용 트리거까지만
◎ UNAInteractionComponent
└ 인터렉터블 여러개를 Tick에서 추적: 가장 가까이에 놓인 인터렉터블 틱마다 갱신(위젯에 출력할 아이템 아이콘 변경을 위함), NearestInteractable에 있는 변수가 상호작용 대상 1순위
◎ ANAPlaceableItemInstance: 맵에 고정되지만 상호작용이 필요한 아이템 오브젝트용 클래스
└ 일단 문 열기/닫기, 레버 및 스위치 등등 맵에 영향을 주는 상호작용 부분 구현

[05/20]
◎ 전역 상호작용 구상하기: 이쪽에서 어떤 조건을 충족하면 저쪽에서 뭔가 트리거됨...
└ 게임 인스턴스에서 전역 상호작용이 필요한 클래스? 객체?들 따로 맵핑하기
◎ ANAPlaceableItemInstance: 레벨에 배치되는 환경 오브젝트, 상호작용 가능함: 문, 레버 등
└ 일단 이것부터 러프하게 구현하기. 레벨 테스트용으로
◎ 위젯 인터렉션 컴포넌트?? 월드에 배치된 위젯과 상호작용 할 수 있음 캐릭터에 붙이기
└ 이걸 인터렉션 컴포넌트의 부모로 둘까? -> 기각. VR 게임에서나 쓸만한듯
◎ 아이템 서브시스템 / 인벤토리 서브시스템 / 플레이어 스테이트 서브시스템 ... : 각자 기능에 따라 별도의 서브시스템으로 나누기
└ 서버 권한에 따라 로직 분기할 필요x
◎ Save&Load 매니저 서브시스템: 각 기능별 서브시스템들에게서 데이터를 받아와서 이를 하나의 USaveGame 컨테이너에 취합하여 저장. 세이브 파일 쓰기/읽기 담당
└ (리슨 서버 기준) 서버 권한에 따라 로직 분기: 호스트 클라(서버)만 세이브/로드를 직접 수행, 게스트 클라는 호스트 클라에게 세이브/로드를 요청. 모든 세이브 파일은 호스트 클라가 소유.

[05/21]
◎ 인벤토리 서브시스템: 여기에서 인벤토리에 아이템 추가/삭제 등의 데이터 관리 및 직렬화/역직렬화에 필요한 데이터 쓰기/읽기
└ 인벤토리 서브시스템에서 플레이어의 인벤토리 정보 관리(add, remove) → 인벤토리 컴포넌트는 인벤토리 서브 시스템에게 add/remove을 요청(접두사 Handle 붙은 메서드들: 인벤토리 서브시스템 함수의 래퍼 함수)
◎ 생각해봤는데 상호작용 컴포넌트나 인벤토리 컴포넌트나 캐릭터가 아니고 플레이어 컨트롤러에 붙이는게 나을듯: 인풋을 직통으로 처리 가능
└ pc에 상호작용 컴포넌트 부착할거면, OnPossess에 AttachToPawn, OnUnPossess에 DetachFromPawn
└ 근데 Attach 안해도 될듯.. 언리얼이 AController에서 트랜스폼 관련 메서드들 죄다 private 처리 해놧음
◎ ANAItemInstance -> ANAItemActor로 리네이밍
◎ **PC에 InventoryComponent와 InventoryWidget을 함께 두기**
└ 인벤토리 컴포넌트와 인벤토리 위젯의 소통은 델리게이트를 통해서만. 최대한 종속성 안생기게
└ 두 객체 사이의 소통에 필요한 델리게이트를 PC에서 바인딩/언바인딩하기
└ PC에서 인벤토리 컴포넌트와 인벤토리 위젯을 관리하면 좋은 점? 멀티플레이어 환경일때, 해당 객체들이 어떤 플레이어(가 빙의중인 폰)의 소유인지 일일히 확인할 필요가 없어짐

[05/22]
◎ 인벤토리 서브시스템에서 제공할 API
└ Add Item
└ Remove Item

(아이템의 Usage에 관한 기능들을 여기서? 아님 아이템 서브시스템에서?)
└ Equip Item: 플레이어 스테이트와 연관됨
└ Unequip Item: 플레이어 스테이트와 연관됨
└ Use Item: 아이템 데이터와 연관됨

◎ 아이템 슬롯
└ 

◎ 인벤토리 컴포넌트의 기능
└ Handle Add Item
└ Handle Remove Item
└ Handle Equip Item
└ Handle Unequip Item
└ Use Item
└ 인벤토리 stack 관련 기능: 인벤토리의 최대 용량, 인벤토리 스택 정리 및 읽기 등
└ 인벤토리 위젯에 broadcast: 렌더링 draw 요청

◎ 아이템 Numeric Data
└ 아이템 데이터의 수량 Quantity: 
	→ 해당 아이템의 현재 수량(반드시 아이템 액터 1개 당 아이템 데이터 수량 1개 x)
	→ 묶음 아이템은 아이템 액터 1개에 아이템 데이터 상의 수량이 여러개일 수 있음 
└ 인벤토리에서의 아이템 수량 / 아이템 묶음 단위 Stack:
	→ 인벤토리 슬롯(칸 1개)에 표시되는 아이템 수량 정보
	→ Max Slot Stack Size: 이 아이템이 인벤토리의 슬롯 1칸에 최대 몇 개까지 들어갈 수 있는가
					0 이면 수량 제한 없음, 1 이상이면 ~ (단 MaxInventoryStackSize보다 항상 작은 값이어야 함)
	→ Max Inventory Stack Size: 인벤토리에 소지 가능한 최대 수량
					    	0이면 수량 제한 없음, 1 이상이면 ~ 
	→ bIsStackable: 소지 가능 여부
└ 아이템 데이터의 Weight:
	→ 인벤토리 슬롯(칸 1개)의 무게의 총합 == 인벤토리 용량
	→ 인벤토리 슬롯 1칸의 무게 = Stack x Item Weight
	→ 인벤토리의 용량을 계산할 때 필요

◎ 인벤토리 연출
└ 데드 스페이스는 인벤토리를 열어도 게임 월드의 시간이 멈추지 않음. 적의 습격을 받을 수 있는 무방비 상태

[05/24]
엔진서브시스템

[05/25]
아이템엔진 서브 시스템: 75프로때 CDO 생김 ㅁㅊ
 - 생성자에서 CDO 넘기고 아이템메타init 실행했을때:
	- ANAItemActor 기본 생성자 들어옴: 블루프린트 CDO인건 탐지햇으나, 아이템엔진 서브시스템 null로 뜨면서 스루 
블프 CDO 컴파일될 때마다 훅, OnConstruction에서 블프 CDO와 일반 인스턴스 동기화

[05/26]
확인할것: 레벨에 블프 액터 배치하고 에디터 껏다 키기
		1. 에디터 로딩때, 엔진아이템서브시스템에서 dt로드하면서 함께 로드되는 블프 cdo 생성(post-initialize 호출 타이밍 		볼 것)이 먼저인지, 아니면 레벨에 배치된 블프 액터 객체를 위한 cdo 생성이 먼저인지 확인
		2. 해당 블프 cdo 생성 이후, 레벨에 배치되었던 액터가 생성되는 시점 확인하기

=> 결과: c++ CDO 생성(75%)
		→ [UNAItemGameInstanceSubsystem::Initialize]  아이템 DT LoadSynchronous 시작
		→ 아이템 DT에 있던) 블프 CDO 생성
		→ [UNAItemGameInstanceSubsystem]  Loaded DataTable: DT_ItemBase 
		→ [UNAItemEngineSubsystem::Initialize]  아이템 메타데이터 맵 초기화 완료
		→ Engine is initialized. Leaving FEngineLoop::Init()
		→ (아마도 에디터 시작 레벨 생성 시작한듯)
		→ [BP_Interaction_Door_C]  블프 일반 객체 생성자, PostInitProperties, PostLoad

=> 결론: 에디터에서) 블프 컴파일때 훅 or 아이템 객체 생성자에서 IsItemActorCDOSynchronizedWithMeta 확인하고 후킹

동적 초기화~~~~ 다시는 안쓸거야~~~~

[05/27]
SynchronizeCDO 때 패키지에 기록된 메모리들 제대로 제거하는 방법을 추가해서 댕글링 포인터 방지하는게 일단 급선무일거 같읍니다...
아니면 이건 언리얼 블프가 하는 방식 응용해도 ㄱㅊ을듯 하고?? 언리얼에서 블프 킬때 CDO에서 복제한 임시 객체 생성되는데, 여기서 막 변경사항 만들고 컴파일&저장하면 이 임시객체를 바탕으로 CDO를 다시 만들고 변경된 사항을 직렬화하는 것 같앗슴
이것처럼  처음에 CDO 동적 초기화할때 오브젝트 플래그에 StandAlone 빼고 Transient 붙여서 객체 생성하고, 블루프린트 컴파일 아님 저장하는 시점을 델리게이트로 후킹해서 이때 오브젝트 플래그를 바꾸든 뭐든 직렬화 객체로 바꾸는 로직을 껴넣어야할거같음

[05/28]
직렬화 안해

[05/29]
◎ 인벤토리 위젯
└ UNAInventoryComponent: UWidgetComponent로 바꿈. 이 컴포넌트가 3D 위젯(UNAInventoryWidget) 보유

◎ 진짜 정말 알고 싶지 않았던 사실: 블루프린트 클래스가 Mark Dirty 상태가 되면 클래스 자체가 바뀜
└ GetClass()->하면 "BP_어쩌구_C" 가 아니라 "REINST_BP_어쩌구_C_숫자"가 나옴 극혐
└ 비교하려는 두 클래스가 모두 블프라는 전제 하에)
	GetClass()->ClassGeneratedBy = Other->ClassGenratedBy 이렇게 비교해야 결과가 제대로 나옴

[05/30]
◎ 인벤토리 3D 위젯: 월드에 배치 가능해야함.
└ 캐릭터의 오른쪽 앞: 인벤토리 위젯 release 시, 약간 카메라 시점이 오른쪽 아래를 향하게 변경됨
└ 보더(백그라운드 영역): 1136 x 640
◎ 배경: 휘어진 영역 -> 휘어진 메쉬에 붙여서 처리
◎ 실제 인벤토리 슬레이트들의 배치 방식: 2d 평면 -> 위젯 블루프린트로 처리

[05/31]
◎ 포토샵으로 인벤토리 텍스처 제작 마무리 [0]
◎ UE 에디터에서 인벤토리 위젯 구성 마무리 [0]
◎ 캐릭터) 스프링 암 <- 스태틱 메쉬 <- 위젯 컴포넌트 [0]
└ 어태치 관계도. 3d 위젯 트랜스폼 설정
◎ '인벤토리 열기' 입력 테스트
└ Release 연출:
	1) 캐릭터: 몸 살짝 오른쪽으로 돌리기(모니터 기준: 약 45도 반측면 오른쪽 응시)
	2) 기본 카메라: 왼쪽으로 앵글 살짝 돌리기(캐릭터보다 덜 돌려야함)
	3) 인벤토리 스프링암:(원래는 기본 카메라와 같은 위치에 있었음) 캐릭터 오른쪽으로 돌리기
└ Collapse 연출:
	1) 캐릭터: 몸 왼쪽으로 돌리기(다시 정면 응시
	2) 기본카메라: 오른쪽으로 앵글 살짝 돌리기 (뒷통수 뷰)
	3) 인벤토리 스프링암: 왼쪽으로 돌려서 기본 카메라와 똑같은 위치로 복귀

Y 위치 +38
◎ 인벤토리 입력
└ 상하좌우 방향키로 인벤토리 슬롯 포커스 이동
└ E: 아이템 사용 or 선택
└ R: 아이템 일괄 정렬(종류별로 or 이름 순으로 -> 정렬 알고리즘 필요)
└ 아이템 선택 정렬: Weapon / Inventory 섹션 나눠서 가능하도록
	└ Q 키 누른 상태에서 아이템 선택(E) -> 그 다음에 선택된 아이템과 위치 교환 
◎ 인벤토리 아이템 줍기 & 빼기
└ 아이템 줍기: 상호작용 키로 줍는다. 아이템에 따라 상호작용 동작이 다름
└ Pickable 아이템은 pick up mode에 따라 '줍기' or '잡기'로 나뉨
└ 줍기: 줍기 애니메이션 등을 수행하자마자 인벤토리에 자동으로 이동됨
└ 잡기: 인벤토리에 소지 불가능한 아이템. 잡기 입력시 캐릭터 손 메쉬에 붙음

[06/01]
◎ 인벤토리 백엔드: 줍줍 -> 아이템 인벤으로 이동 -> 인벤 슬롯에 저장 -> 직렬화 

인벤 위젯 킬때: 왼 -> 오 (yaw 190)
인벤 스프링암 회전 끝난뒤 -> 인벤토리 위젯 회전 살짝(위치 + 회전)
일단 루트 컴포넌트를 회전해야할듯?


스플라인 컴포넌트 포인트 총 3개: 
[0]: 이건 연출 시작 직전, 카메라 컴포넌트의 트랜스폼과 일치시켜야 함
[1]: 아이작 옆구리 트랜스폼 -> 고정되어있음
[2]: 인벤토리 위젯 끌 때 카메라 원위치 할 트랜스폼 -> 고정하자

(X=-1540.000000,Y=-190.000000,Z=248.150101)
(X=-1869.048215,Y=-252.986007,Z=172.321583)

[06/02]
◎ 월드에서 아이템 줍기 -> 인벤토리에 아이템 보관 


[06/03]

[01, IT_Consumable, SmallPostion_C, 10], [03, IT_Consumable, SmallPostion_C, 2], [07, IT_Ammo, Ammo01_C, 50], 
[12, IT_Consumable, BigPostion_C, 8], [14, IT_Ammo, MechineGunAmmo_C, 90], [15, IT_Ammo, MechineGunAmmo_C, 100],
[19, IT_Ammo, MechineGunAmmo_C, 80],  [20, IT_Ammo, Ammo01_C, 50],  [25, IT_Consumable, GreatPostion_C, 5]   

[01, IT_Consumable, BigPostion_C, 8], [02, IT_Consumable, GreatPostion_C, 5], [03,  IT_Consumable, SmallPostion_C, 10],
[04, IT_Consumable, SmallPostion_C, 2],  [05, IT_Ammo, Ammo01_C, 50],  [06, IT_Ammo, Ammo01_C, 50],
[07, IT_Ammo, MechineGunAmmo_C, 100], [08, IT_Ammo, MechineGunAmmo_C, 90], [09, IT_Ammo, MechineGunAmmo_C, 80]

아니 도대체 왜 Outer가 날라가 있냐고 미쳣냐고

[06/04]
GET_MEMBER_NAME_CHECKED(UCylinderBuilder, OuterRadius)
인벤토리 컴포넌트의 슬롯 - 인벤토리 위젯의 슬롯(버튼) 매핑하기: 슬롯ID와 슬롯(버튼) 변수명 일치시키기


[06/05]
아이템 디스크립션 최대 글자수: (공백포함) 207

[06/06]
인벤토리 카메라 앵글 전환 시 보간
아이템 아이콘 및 수량 정보 인벤토리 위젯에 리드로우
아이템 종류 세분화
인벤토리 위젯 내에서 네비게이션

[06/07]
게임 & ui 동시 입력 처리
마우스 자꾸 튀어나옴 
유아이에 키보드 포커싱 처음 들어갈때 게임 입력 끊김 미친게야

[06/08]
회복 아이템
구급팩: 소형/중형/대형 (1칸, 3칸, 5칸(풀)) 인벤토리 1칸씩 
	자동 사용 기능: 인벤 안키고 단축키로 회복 아이템 자동 사용->대용량 우선
스테이시스 팩: 에너지 충전. 단축키로 바로 충전 가능
산소탱크: 크레딧으로 구매. 인벤토리 열고 직접사용

무기 획득 방식: 상점에서 구매 
탄약: 드랍 or 구매. 탄약 드랍은 보유한 무기에 맞는 탄약이 드랍됨.( 탄약 드랍 회수는 정해져잇음. 무기가 적음녀 탄약드랍되는 탄약 종류가 적음->한 종류당 드랍으로 파밍 가능한 탄약이 상대적으로 많음. 무기가 많음->드랍으로 나오는 탄약의 종류가 많아짐.->한 종류 당 드랍으로 얻을 수 있는 탄약 개수 줄어듬)

슈트의 레벨에 따라 인벤토리 용량 달라짐 순차적 업그레이드만 가능(1->3 점프 불가)

키네시스 모듈 

INAItemUseInterface: 아이템 사용 로직 추상화

[06/09]
아이템 데이터에 기본 quantity 설정하기: 
필요한 변수: Is Stackable == true, max slot stack size(한 묶음에 들어갈 수 있는 최대 개수), 

// @TODO: 인벤토리 위젯에서 버튼에서 아이템 데이터 역추적하는 함수 만들기

[06/10]

[06/11]

[06/12]

[06/13]

[06/14]
상호작용 로직 리팩토링:
Interaction Component: 상호작용 이니시 -> pickable/placeable 구분
pick up 모드: holdable 삭제

[06/15]
아이템 계층구조 수정

[06/16]
아이템 계층구조 수정: 생성자에서 어태치먼트 설정 싹 빼기. 단 루트 컴포넌트를 ItemCollision으로 설정하는 부분만 생성자에서
Error        LogSceneComponent         Component 'SphereComponent /Engine/Transient.World_2:PersistentLevel.BP_Test_C_0.ItemCollision(Sphere)' has 'NAItemWidgetComponent /Engine/Transient.World_2:PersistentLevel.BP_Test_C_0.ItemWidgetComponent' in its AttachChildren array, however, 'NAItemWidgetComponent /Engine/Transient.World_2:PersistentLevel.BP_Test_C_0.ItemWidgetComponent' believes it is not attached to anything
Error        LogSceneComponent         Component 'SphereComponent /Engine/Transient.World_2:PersistentLevel.BP_Test_C_0.ItemCollision(Sphere)' has 'SphereComponent /Engine/Transient.World_2:PersistentLevel.BP_Test_C_0.TriggerSphere' in its AttachChildren array, however, 'SphereComponent /Engine/Transient.World_2:PersistentLevel.BP_Test_C_0.TriggerSphere' believes it is not attached to anything
Error        LogSceneComponent         Component 'SphereComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.ItemCollision(Sphere)' has 'NAItemWidgetComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.ItemWidgetComponent' in its AttachChildren array, however, 'NAItemWidgetComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.ItemWidgetComponent' believes it is not attached to anything
Error        LogSceneComponent         Component 'SphereComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.ItemCollision(Sphere)' has 'SphereComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.TriggerSphere' in its AttachChildren array, however, 'SphereComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.TriggerSphere' believes it is not attached to anything
Error        LogSceneComponent         Component 'SphereComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.ItemCollision(Sphere)' has 'StaticMeshComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.ItemMesh(Static)' in its AttachChildren array, however, 'StaticMeshComponent /Game/00_ProjectNA/02_Level/Level_NAMainGame.Level_NAMainGame:PersistentLevel.BP_Test_C_1.ItemMesh(Static)' believes it is not attached to anything

상호작용 시: 아이템 액터 생성 파괴 될때마다->OnFocusedItemFound & OnFocusedItemLost 자동 호출됨. 단 어태치되면서 생성된 액터는 이거 안들어옴


언리얼 5.4 패키징 버그: 엔진 컨텐츠 폴더가 가끔 쿠킹에 포함 안됨 미친게야

[06/23]
upgrade bench 아이템 액터: 상호작용 - 위젯 버튼으로 열고/닫기, 위젯 버튼 입력 받기, 위젯 열고 있는 동안을 어떻게 처리할 것인가?
upgrade bench 컴포넌트: 캐릭터 인벤토리 컴포넌트에서 보유중인 업그레이드 아이템 & 노드 아이템 추적, gas에서 해당 캐릭터의 강화 상태 받아오기
upgrade bench

suit upgrade tree: 노드 전부 수동으로 구성,  해방 순서 -> 정적 배열 인덱스로 관리

Upgrade Item Description widget 사이즈: 1680 X 167

공간 확보 안된 곳에서 인벤토리 위젯 펼치면, 인벤 위젯 안보임(다른 오브젝트에 가려짐) -> 충돌처리 필요할까?

// 아이템 액터 계층구조 버그: 트러블 슈팅
ItemCollision을 루트로 두고 있는데 초기에 기본으로 만드는 서브 오브젝트 쉐입으로 인해 클라이언트와 서버간 동기화시에 충돌체가 서로 다른 컴포넌트로 인정됨 (거의 그럼 확실은 아닌데 계속 동기화 하는데 문제가 있었음)
또한 초기에 루트 컴포넌트를 아에 안두고 시작하면 기본으로 매시가 부모가 되는데, 매시는 개별적인 오프셋이 지정되기 때문에 루트 컴포넌트를 갈아끼울때 위치 재조정이 까다로움
문제를 간소화하기 위해 서브 오브젝트로 씬컴포넌트 스텁을 하나 만들어서 루트로 둔 다음에 런타임에 아이템 콜리전으로 갈아끼운 다음 리플리케이션을 키고 Net Addressable하게 설정하고, Replicate SubObject에 넣어둠
이후 클라이언트랑 서버가 위치 동기화를 하는데 문제가 없음을 확인함
블루프린트에서 값을 수정하지 않고 데이터테이블에서 초기화하는게 목적이다보니까 굳이 쉐입 컴포넌트가 블루프린트 상에서 떠야할 이유는 없다고 생각하기도 했고

~FObjectInitializer -> PostConstructInit ->InitProperties ->
// InitProperties 일부
if (!bNeedInitialize && bCanUsePostConstructLink)
	{
		// This is just a fast path for the below in the common case that we are not doing a duplicate or initializing a CDO and this is all native.
		// We only do it if the DefaultData object is NOT a CDO of the object that's being initialized. CDO data is already initialized in the
		// object's constructor.
		if (DefaultData)
		{
			if (Class->GetDefaultObject(false) != DefaultData)
			{
				for (FProperty* P = Class->PropertyLink; P; P = P->PropertyLinkNext)
				{
					bool bIsTransient = P->HasAnyPropertyFlags(CPF_Transient | CPF_DuplicateTransient | CPF_NonPIEDuplicateTransient);
					if (!bIsTransient || !P->ContainsInstancedObjectProperty())
					{
						if (P->IsInContainer(DefaultsClass))
						{
							P->CopyCompleteValue_InContainer(Obj, DefaultData);
						}
					}
				}
			}
			else
			{
				// Copy all properties that require additional initialization (e.g. CPF_Config).
				for (FProperty* P = Class->PostConstructLink; P; P = P->PostConstructLinkNext)
				{
					bool bIsTransient = P->HasAnyPropertyFlags(CPF_Transient | CPF_DuplicateTransient | CPF_NonPIEDuplicateTransient);
					if (!bIsTransient || !P->ContainsInstancedObjectProperty())
					{
						if (P->IsInContainer(DefaultsClass))
						{
                            // 이 부분이 호출됨
							P->CopyCompleteValue_InContainer(Obj, DefaultData);
						}
					}
				}
			}
		}
	}
-> CopyCompleteValue_InContainer -> CopyCompleteValue


[~06/26]
아이템 액터 bp cdo 동적 초기화: 
0. 아이템 dt: TSoftClassPtr<ANAItemActor> ItemClass -> TSoftClassPtr를 활용하여 아이템 액터 클래스 참조
1. 아이템 엔진 서브 시스템 initialize:
└ 1) 아이템 dt load synchronous -> 이때 ItemClass는 로드 안됨
└ 2) TMap<TSoftClassPtr<ANAItemActor>, FDataTableRowHandle> SoftItemMetaData에 미리 dt 데이터 인스턴싱
└ 3) SoftItemMetaData 순회: Key.LoadSynchronous() 호출 -> ANAItemActor 네이티브 생성자: UNAItemEngineSubsystem에서 SoftItemMetaData를 읽어옴 -> GetClass()를 키 값으로 value 검색 -> 검색된 Value(FNAItemBaseTableRow*)로 서브오브젝트 ItemCollision & ItemMesh 동적 초기화
└ 4) 아이템 엔진 서브 시스템: 로드 바로 다음줄에서 에디터 전처리기 걸어두고, 블프 에셋 컴파일:
	동적으로 초기화된 내용을 블프 에디터의 계층 트리 & 디테일 패널에 반영하기 위함

아이템 액터 구조 개선:
◎ ~BeginPlay 이전까지: 무조건 깡통 씬 컴포넌트를 루트로 고정. 생성 단계 및 에디터 런타임에서 서브오브젝트 동적 수정이 일어날때, ItemCollision(동적 편집 대상)을 루트로 두니까 각종 문제 발생(인스턴스 객체와 아키타입 객체 간 서브오브젝트 보유 구조가 달라서 발생하는 문제들. 서브오브젝트 변경이 일어났을때, 수정 전 컴포넌트가 삭제되지 않는 문제, ItemCollision 변경시 어태치된 자식 컴포넌트들 계층 트리 무너지는 문제 등)
◎ 런타임 BeginPlay 단계 때, 필요에 따라 ItemCollision을 루트로 변경 & 어태치 자식 이전 -> Super::BeginPlay -> 아이템 액터 서브오브젝트들의 피직스 설정

◎ 인벤토리 위젯: 공간 확보가 안되면 위젯이 가려지는 문제: 머티리얼에서 bDisableDepthTest= true

아이템 액터 상호작용 딜레이 문제: 몬스터가 떨궈서 생긴 아이템 -> 오버랩 end부터 들어옴

[06/29]
◎ 포트폴리오 수정 사항: PickupMode 변경점 다시 써야 함.

Pickup Mode 롤백: AutoUse-> 인벤x, 들기x, 상호작용 하자마자 자동 사용
			  Inv두새교-> 인벤 수납만 가능
			CarryOnly -> 들기만 가능

[07/03]
- AddInstanceComponent 생성자에서 제거
  - 런타임에서 Hierarchy는 유지되지만 에디터상으로만 깨진 채로 나오는거라 에디터 로드 시점에서 에셋 전체 리컴파일을 돌림
- PostInitProperties 이후에 컴포넌트들이 NULL로 CDO에 의해 초기화 되는 문제 해결 (Property에 Instanced를 넣음, 위 초기화 조건이 Transient이거나 Instanced이면 해당 복사가 발생하지 않음)
- ItemCollision에서 Replicated 키워드 제거
- Weapon: ItemMesh에 붙은 컴포넌트들 계층 관계가 블프 에디터 UI에 안뜸
- BlueprintCompile에서 바뀐거만 업데이트
- 기존에 루트 컴포넌트가 부모가 아닌 애들에 대해서 다 붙였었는데 생성자에서 만든 콜리전과 매시가 있으니까 자식이 알아서 붙이도록 책임 위임

[07/07]
◎ 아이템 액터 풀링 추가 검토: 

1. 아이템 생성/스폰 로직 검토 및 수정
UNAItemEngineSubsystem::CreateItemDataByActor 함수:

현재 이 함수는 ANAItemActor가 생성될 때 UNAItemData를 생성하고 연결하는 역할을 합니다. 풀링을 도입한다면, 이 함수는 아이템 액터의 '획득' 요청이 들어왔을 때, 새로운 액터를 스폰하는 대신 액터 풀에서 사용 가능한 액터를 가져오도록 수정되어야 합니다.

검토 내용:

풀에서 해당 클래스 타입의 액터를 찾아 반환하는 로직 추가.

풀에 사용 가능한 액터가 없을 경우에만 GetWorld()->SpawnActor를 호출하여 새로운 액터를 생성하는 폴백(fallback) 로직 구현.

풀에서 가져온 액터에 UNAItemData를 할당하는 ANAItemActor::AssignItemDataToChildActor와 유사한 OnPooledAcquired 함수를 호출하여 필요한 초기화가 이루어지도록 합니다.

AMonsterSpawner::SpawnMonster 함수:

몬스터가 아이템을 드랍할 때 GetWorld()->SpawnActor를 직접 호출하여 아이템 액터를 스폰합니다. 이 부분도 UNAItemEngineSubsystem의 풀링 로직을 사용하도록 수정해야 합니다.

검토 내용: UNAItemEngineSubsystem을 통해 아이템 액터를 생성하도록 호출 방식을 변경합니다.

2. 아이템 파괴/제거 로직 검토 및 수정
UNAItemEngineSubsystem::DestroyRuntimeItemData 함수:

현재 이 함수는 ItemActor->Destroy()를 호출하여 액터를 즉시 파괴합니다.

검토 내용:

액터를 Destroy()하는 대신, 해당 액터를 비활성화하고 (예: SetActorHiddenInGame(true), SetActorEnableCollision(false), SetActorTickEnabled(false)) 액터 풀로 반환하는 로직을 추가합니다.

액터가 풀로 반환되기 전에 ANAItemActor에 추가될 OnPooledReleased 함수를 호출하여 모든 런타임 상태를 초기화하도록 합니다.

ANAItemActor::Destroyed 함수 및 ANAItemWidgetPopupActor:

아이템이 파괴될 때 ANAItemWidgetPopupActor를 스폰하여 위젯 팝업의 애니메이션을 처리합니다. 풀링 시에는 실제 액터 파괴가 일어나지 않으므로, 이 PopupActor의 생명주기와 ItemWidgetComponent의 관리가 변경되어야 합니다.

검토 내용: ANAItemActor가 풀로 반환될 때 ItemWidgetComponent를 적절히 비활성화하거나, 팝업 애니메이션 처리 후 위젯만 RemoveFromParent하고 액터는 풀로 반환되도록 조정해야 합니다.

ANAPickableItemActor::SetInteractionPhysicsEnabled 함수:

이 함수는 아이템의 상호작용 가능 여부에 따라 물리 및 오버랩 이벤트를 활성화/비활성화합니다. 풀링된 액터가 재활용될 때 이러한 상태들이 올바르게 초기화되고 설정되는지 확인해야 합니다.

검토 내용: OnPooledAcquired 및 OnPooledReleased 함수 내에서 이 함수를 호출하여 초기 상태를 설정하도록 통합하거나, 풀링 로직 자체가 이 함수가 적절히 호출되도록 보장해야 합니다.

3. 아이템 상태 관리 및 초기화
ANAItemActor 클래스:

새로운 함수 추가:

OnPooledAcquired(UNAItemData* InItemData): 풀에서 액터를 가져와 사용할 때 호출될 함수. 액터의 모든 컴포넌트(충돌, 메시, 위젯 등)를 활성화하고, InItemData를 연결하며, 필요한 초기 상태(예: 수량 랜덤화)를 설정합니다.

OnPooledReleased(): 액터를 풀로 반환할 때 호출될 함수. 액터의 모든 컴포넌트를 비활성화하고, 물리 시뮬레이션을 끄고, ItemDataID를 NAME_None으로 초기화하는 등 모든 런타임 상태를 재설정합니다.

UNAItemData 클래스:

IDCount는 아이템 데이터의 고유 ID를 생성하는 데 사용되므로, 풀링된 액터가 새로운 UNAItemData와 연결될 때 이 ID 생성이 제대로 되는지 확인해야 합니다.

검토 내용: UNAItemData 자체는 액터 풀링의 직접적인 영향을 받기보다는, 액터가 재활용될 때 어떤 UNAItemData와 연결될지에 대한 관리가 중요합니다.

4. 네트워크 복제 (Replication) 검토
ANAItemActor의 복제 설정:

bReplicates = true로 설정되어 있으며, bWasChildActor와 같은 프로퍼티도 복제됩니다.

검토 내용:

액터가 풀에서 활성화/비활성화될 때 SetReplicates(true/false)를 사용하여 불필요한 네트워크 트래픽을 줄이는 것을 고려합니다.

액터의 활성화/비활성화 상태와 ItemDataID 같은 핵심 데이터가 서버와 클라이언트 간에 정확히 동기화되도록 OnRep 함수들을 확인하거나 필요시 추가합니다.

◎ GAS를 활용하여 상호작용 시스템 리팩토링하기


[07/08]
◎  AActor::PostSpawnInitialize
	// General flow here is like so
	// - Actor sets up the basics.
	// - Actor gets PreInitializeComponents()
	// - Actor constructs itself, after which its components should be fully assembled
	// - Actor components get OnComponentCreated
	// - Actor components get InitializeComponent
	// - Actor gets PostInitializeComponents() once everything is set up
	//
	// This should be the same sequence for deferred or nondeferred spawning.
└ PostSpawnInitialize에서 PostActorCreated호출. 즉 OnConstruction보다 먼저 호출됨. 
└ PostActorCreated -> ActorCreated 델리게이트 ... -> OnConstruction ... -> BeginPlay

◎ FinishSpawning에서 ExecuteConstruction 호출: 여기서 Blueprint Construction Script 호출 후 OnConstruction 호출 후 PostActorConstruction

◎ ULevel::AddLoadedActors (#if WITH_EDITOR
└ if (bAreComponentsCurrentlyRegistered)
			{
				Actor->RegisterAllComponents();
			}

◎ USCS_Node::ExecuteNodeOnActor

◎ GIsReinstancing: True if actors and objects are being re-instanced.

◎ AActor::ExecuteConstruction

◎ AActor::bHasDeferredComponentRegistration: 컴포넌트 등록 지연을 결정하는 bool 변수(private).
└ 블루프린트에서 생성된 인스턴스라면, SCS execution을 먼저 호출한 다음에 컴포넌트들을 register해야 함(FinsihSpawning)

◎ PostSpawnInitialize: SpawnActor에서만 호출됨

◎ 버그 1: 레벨에 배치한 아이템 액터(아이템 콜리전이 루트로 가는 인스턴스들): 피직스 시뮬레이트 안됨
◎ 버그 2: 게스트 클라의 상호작용 시도가 안됨
└ Interactable Focus에 추가하는건 잘 적용됨(서버/클라 캐릭터 나눠서 각 캐릭터의 Interaction 컴포넌트에 등록)
└ 클라에서 상호작용 호출(ToggleInteraction)하면, NACharactor1(서버)의 ToggleInteraction이 호출됨.